#!/bin/bash
#============================================================================
# Title       : asm
# Description : Manage disks and volumes for Oracle ASM
# Author      : Bart Sjerps <bart@outrun.nl>
# Version     : 1
# Manual      : asmdisks
# License     : GPLv3+
# ---------------------------------------------------------------------------
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.
# ---------------------------------------------------------------------------
# Revision history:
# 2018-08-20 : Embedded manpage
# 2018-04-06 : Add $PATH to support remote and scripted execution
# 2017-12-14 : Bugfix for import function
# 2017-10-04 : Bugfix for SCSI id's with whitespace (Linux TGTD)
# 2017-09-13 : AWK Bugfix for SCSI id's starting with '0'
# 2017-03-14 : ScaleIO support
# 2017-01-30 : bugfix for rename
# 2016-11-09 : DSSD udev bugfix
# 2016-10-19 : Overhaul, many fixes and improvements
# 2016-09-11 : EL7 support, bootdisk detection & tempdir usage
# 2016-08-18 : Added EMC DSSD support, output for larger volume sizes
# 2015-03-10 : Support for EMC Powerpath
# 2015-03-05 : Rewrite of listdisks & create, added multi option
# 2015-02-24 : Added TAB separator option for scripting, small bugfix
# 2014-11-06 : Added import, rename and -h/-? option
# 2014-10-22 : Created
# ---------------------------------------------------------------------------
#============================================================================
# Configuration parameters:
# ---------------------------------------------------------------------------

rulesfile=/etc/udev/rules.d/99-asm.rules

# Ensure it works from a scripted or remote ssh environment
export PATH=$PATH:/sbin

#============================================================================
# Initialization - Logging - Etc.
# ---------------------------------------------------------------------------

# Create temporary workdir - cleanup the mess when script ends good or bad
readonly WORKDIR=$(/bin/mktemp --tmpdir -d)
cleanup() { /bin/rm -rf ${WORKDIR:-/none} ; exit ${rc:-99} ; }
trap "cleanup" EXIT INT TERM HUP

#============================================================================
# Usage:
# ---------------------------------------------------------------------------
usage() {
  cat <<- EOF
	Usage: $(basename $0) [-n] [-t] <command> [args]
	
	@B asm
	is a replacement for the
	@B oracleasm
	command provided via Oracle ASMlib. It attempts to provide similar functionality using a simple script
	and Linux UDEV rather than tweaking the kernel with an add-on kernel module,
	complex configuration and binary files.
	
	It will create block devices from disks, partitions or mapper devices,
	under /dev/oracleasm/ (default) for use with Oracle and changes permissions to
	grid:asmdba to allow Oracle ASM read/write access to those disks (only).
	Mapper devices can be multipath devices, LVM logical volumes, or any other
	block device managed by Linux device-mapper.
	
	The administration of those files is done through the
	@I /etc/asmtab
	configuration file, which holds the asmdisks volume name, volume type,
	and the identifier, to provide persistent naming across reboots
	and reconfiguration. You may manually edit this file if so needed. The
	@B UDEV
	configuration in /etc/udev/rules.d/ is built from the definitions in asmtab.
	@P
	This tool is completely out-of-band, which means it is only used for generating
	and activating the udev rules file and does nothing until an administrator runs
	the tool. You may even remove asmdisks and the configuration will still keep working.

	Options:
	 -n   no headings
	
	 -t   use TAB separator (for scripting) instead of column formatted (implies -n)
	
	 rescan  lets the kernel probe for new SCSI devices (after hot-adding disks)
	
	 createdisk <label> <block device>  adds a disk as /dev/oracleasm/<label>
	 If you want the disk to appear under another path (such as /dev/iorate) then use
	 the relative path as label (i.e. asm createdisk iorate/vol1 <id>)
	 The block device can be a raw disk (i.e. /dev/sdX), a previously created (empty)
	 disk partition (/dev/sdX1), or a device-mapper block device, to be specified as
	 any mapper device that points to the correct /dev/dm-X device,
	 such as LVM logical volumes (i.e. /dev/myvg/lvol1), multipath devices (/dev/mapper/mpathX)
	 etc. "asm" will attempt to figure out the type of device and specify the correct ID in asmtab.
	
	 deletedisk <label>  deletes the disk from /dev/<diskstring>/.
	 It will not be completely removed but re-appear
	 as /dev/sdX or /dev/dm-X etc. Be careful, if the disk is still in use it could
	 result in I/O errors and even dataloss.
	
	 renamedisk <label> <new>      renames the disk (beware if disk is in use!)
	 
	 scandisks   processes any changes in asmtab, creates new UDEV rules
	 (run it after createdisk/deletedisk to
	 activate your changes). It's called automatically after createdisk/deletedisk actions.

	 disks       shows all SCSI disks, SCSI connections, size and path
	 also shows SCSI addresses (handy for figuring out which VMDK / iSCSI / etc volume is used)
	
	 multi       list multipath devices
	
	 list        show all devices currently configured under /dev/oracleasm
	
	 import      Imports all volumes from /dev/sd* that are labeled as ASMdisk
	 i.e. they have an Oracle ASM disk signature created by another host (cloning) or another node (RAC. 
	 It simply imports volumes as vol01, vol02, etc. 
	 as ASM does not care what the Linux device name looks like anyway.
	
	 dump  Shows the contents of $rulesfile
	*SCSI UUID*
	The scsi identifier is retrieved via the
	@B scsi_id(8)
	command and depends on the OS and hardware layer to provide this.
	The VMware default (all products) is to have this ID disabled. It must be re-enabled with
	@P
	@B disk.EnableUUID = "TRUE"
	@P
	in the VM's VMX configuration file.
	This tool will not work without this setting.  You may verify if that works using the command
	@br
	@B scsi_id --whitelisted /dev/sda
	@br
	or running "asm" without options (it will complain if /dev/sda does not show a SCSI identifier).
	
	*DISKSTRINGS*
	The default diskstring under which new volumes are placed is /dev/oracleasm/ with
	ownership grid:asmdba and mode 0660.
	@br
	You may want to configure volumes elsewhere and with different permissions. If you specify a
	relative path as volume name then the volume will be configured under /dev/<path>/name,
	for example "iorate/vol1" will appear as /dev/iorate/vol1.
	The permissions will be the default (grid:asmdba) unless an entry for the new diskstring
	is defined in asmtab (needs to be done manually). At initial creation, "asm" defines
	one special case (in asmtab) for iorate:
	@nf
	PATH=iorate:root:iops:0660
	@fi
	This means if you create volumes as iorate/<volname> they will have permissions root:iops @ mode 0660.
	This allows the IORate tool to run under userid "iorate" having group membership "iops" with access
	to those devices - without giving the user full access to all disks (such as by making it
	a member of the "disk" group). This prevents IORate to accidentally overwrite OS or ASM
	devices (when using the iorate RPM package, that is). IORate will only have direct access
	to volumes under /dev/iorate.
	ASM will fall back to grid:asmdba if the specified user/group does not exist.
	Another purpose for having an additional diskstring is if you want to run more
	than one Oracle ASM instance - each can have it's own diskstring and permissions.
	The default grid:asmdba owner/group can be altered by setting
	@br
	PATH=oracleasm:user:group:mode in the asmtab file.
	
	*ASMTAB file format*
	Define all non-default diskstrings as
	@nf
	
	PATH=<diskstring>:<owner>:<group>:<mode>
	
	@fi
	Non-defined diskstrings will have default ownerships/modes.
	@br
	For every volume to be defined, register one entry in asmtab as
	@nf
	
	<diskstring/volumename> <type> <id>
	
	@fi
	diskstring may be omitted (defaults to "oracleasm"). Type is currently either "scsi" or "mapper".
	@br
	id is either a scsi_identifier (such as SCSI device "36000c29f825cd85b5fcc70a1aadebf0c" or
	iSCSI id "1IET_00010001") or a similar identifier appended with :<partnum>,
	such as "36000c29f825cd85b5fcc70a1aadebf0c:2" indicating the 2nd partition on that
	SCSI disk, or a name as it appears under /dev/mapper/ such as /dev/mapper/myvg-vol1.
	@br
	Normally you should not have to edit asmtab manually, however in some cases it may become handy.
	
	*Supported disk types*
	asmdisks currently supports the following block device types:
	@P
	- Plain SCSI disk (/dev/sd*)
	@br
	- Linux Multipath (/etc/multipath/*, multipath -ll)
	@br
	- Linux Logical Volumes (/dev/vgname/lvname)
	@br
	- DellEMC Powerpath (/dev/power*)
	@br
	- DellEMC ScaleIO (/dev/scini*)
	@br
	
	*RAC and Clusterware*
	Be aware that Oracle RAC requires shared devices as ASM volumes. This means running
	RAC with anything else than full SCSI disks or SCSI disk partitions will not work.
	
	*Files*
	/etc/asmtab
	@br
	/dev/oracleasm/
	@br
	/dev/iorate/
	@br
	/etc/udev/rules.d/99-asm.rules
	@br
	/etc/scsi_id.config
	
	*RAW SCSI disks or disk partitions*
	Many administrators prefer to create a primary partition first on each disk,
	then use that for ASM (this is the standard way of using disks with Oracle ASMLib).
	My preference is to hand full disks (not partitioned) to ASM. By using "asm"
	the risk of a rookie administrator creating filesystems or anything else on that disk
	is virtually eliminated, because the disk device is removed from /dev/sdXX,
	and reappears as /dev/oracleasm/volXX. An admin who would still create a filesystem on
	such a device should be sent back to basic UNIX administration training.
	Using full disks eliminates the need for disk alignment and some extra administration steps.
	@P
	Note that with Enterprise Linux 7 this feature of udev no longer works and the only option
	is to add symlinks to devices in /dev/ so this is now the standard behaviour of asmdisks.
	
	*bash completion*
	If you have the package bash-completion installed, you may use TAB to show possible
	command options or auto-complete things like disk and volume names.
	
	*use in scripts*
	If you want to parse the output of "asm" (list/disks) for usage in scripts, you can use the "-t"
	option so that the output is TAB separated instead of column formatted.
	@br
	In future versions, the columns and output order may change.
	
	*boot disk protection*
	asmdisks attempts to detect which disk is used as bootdisk and prevent messing with this disk directly.
	In some cases the detection fails. You may add the bootdisk to /etc/asmtab manually.
	
	*Known issues*
	- Modifying the UDEV config requires running "udevadm trigger" which in turn triggers network reconfiguration.
	A known issue when using DHCP is that the network scripts attempt to start a 2nd dhclient - which fails and
	results in errors in the syslog. You can safely ignore these.
	@br
	- Enabling or disabling Linux Multipath may require a reboot to prevent strange asmdisks behaviour.
	
	*Bugs*
	Likely. Currently "asm" does not do a lot of validation checking so in classic UNIX style, it offers
	many ways to mess up. Especially via directly editing asmtab. You have been warned.
	@br
	That said, asm is "out of band", in other words it is not required for correct presentation of
	ASM devices. You could deinstall asmdisks, reboot and the ASM volumes would still be there (because of
	the 99-asm.rules UDEV file). In the end, "asm" only manages this file and you may verify at any time
	if the contents are correct or make backup copies of the file at any time.
	@br
	Note that to avoid potential problems with boot devices, /dev/sda is excluded from
	any manipulation (I learned the hard way ;)
	@br
	So even if you mess up, you should be able to boot and fix problems by removing/restoring
	99-asm.rules followed by "udevadm trigger" to reset udev.
	Then fix issues in asmtab and retry "asm scandisks".
	@P
	EMC Powerpath has not yet been fully tested with asm, but this would
	only be required for physically deployed hosts. Likewise for non-standard SCSI devices such as
	paravirtualized devices, or any other disk type that shows up different from what is expected.
	@br
	Roughly speaking, any device that shows up as /dev/sdXX in Linux (i.e. it is an "sd" device type) should work.
	If you want support for another non-standard device type, let me know and I will see if it's possible to add support.
	
	*See also*
	wipedisk(1), asmstat(1), udev(7), udevadm(8), scsi_id(8)

	EOF
}
version() {
  local version=$(awk -F: '/^# Version / {sub(/ /,"",$NF) ; print $NF}' $0)
  local author=$(awk -F: '/^# Author / {sub(/ /,"",$NF) ; print $NF}' $0)
  local license=$(awk -F: '/^# License / {sub(/ /,"",$NF) ; print $NF}' $0)
  case $license in
    GPLv3+) local ltext="License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>." ;;
    *)      local ltext="license $license (unknown)"
  esac
  cat <<- EOF
	$(basename $0) ${version:-0.0}
	Written by ${author:-<No Author>}, ${ltext}
	@br
	If you have suggestions for improvements in this tool, please send them along via the above address.
	
	Copyright (c) 2018 ${author% <*}
	EOF
  echo @br
  echo This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.
}

mandump() {
  test -x /usr/bin/help2man || exit 10
  local desc=$(awk -F: '/^# Description/ {sub(/ /,"",$NF) ; print $NF; exit}' $0)
  local sect=$(awk -F: '/^# Section/     {sub(/ /,"",$NF) ; print $NF; exit}' $0)
  local manual=$(awk -F: '/^# Manual/    {sub(/ /,"",$NF) ; print $NF; exit}' $0)
  local source=$(awk -F: '/^# Source/    {sub(/ /,"",$NF) ; print $NF; exit}' $0)
  SOURCE_DATE_EPOCH=$(stat -c %Y $0); export SOURCE_DATE_EPOCH
  help2man -N -n "$desc" -s "${sect:-1}" -S "${source:-Outrun}" -m "${manual:-Outrun manual}" $0 | sed "s/^@/\./"
}

case $1 in
  -\?)       man $(basename $0) ; exit;;
  --help)    usage   ; exit ;;
  --version) version ; exit ;;
  --mandump) mandump ; exit ;;
esac

#============================================================================
# Functions
# ---------------------------------------------------------------------------

# Messages
die() { echo "$(basename $0) error: $@" >&2 ; exit ; }
err() { echo "$(basename $0) error: $@" >&2 ; }
msg() { [[ "$QUIET" != "Y" ]] &&  echo "$(basename $0): $@" ; }

# Check if we are root, else quit
chkroot() { (($(id -u)==0)) || rc=20 die "Run as root" ; }

# calculate major or minor numbers given a block device
major() { echo "ibase=16; $(stat -Lc '%t' $1 | tr 'a-z' 'A-Z')"|bc ;}
minor() { echo "ibase=16; $(stat -Lc '%T' $1 | tr 'a-z' 'A-Z')"|bc ;}

# Get diskstrings from asmtab including default "oracleasm"
diskstrings() { awk 'BEGIN {print "oracleasm"; } $1 ~ "/" {print substr($1,1,match($1,"/")-1)}' /etc/asmtab | sort | uniq ; }

# Update udev rules
udevupdate() { udevadm control --reload-rules ; udevadm trigger ; }

# Lookup block device type
devicetype() { awk -v m=$1 '$1=="Block" {f=1} ; f==1 && $1==m {print $2}' /proc/devices ; }
devtrans() { echo "$1" | sed "$(awk 'BEGIN { OFS="/" } $1=="Block" {f=1;getline} ; f==1 {printf "s/\\<" $1 "\\>/" $2 "/;" } END { f=1 }' /proc/devices)" ; }

# get SCSI identifier. scsi_id path changed in EL7, check both
getscsi() { 
  test -x /sbin/scsi_id && /sbin/scsi_id -g $1 && return 0
  test -x /usr/lib/udev/scsi_id && /usr/lib/udev/scsi_id -g $1 && return 0
  return 1
}

# Find the bootdisk. /boot must be mounted for this to work
bootdisk() { 
  grep -qw "^BOOTDISK" /etc/asmtab && awk -F= '$1=="BOOTDISK" {gsub(/\/dev\//,"") ; print "/dev/" $2 }' /etc/asmtab && return 0
  grep -qw "/boot" /proc/mounts || return 1
  awk '$2=="/boot" {print $1}' /proc/mounts | tr -d '0-9' 
}

# Verify if we can list the scsi_id - if not, probably running VMware without uuid enabled
checkuuid() {
  [[ "$(id -un)" != "root" ]] && return
  bootdisk &>/dev/null || { err "/boot not mounted" ; return 1 ; }
  getscsi $(bootdisk) &>/dev/null || err "scsi_id failed! Enable disk.EnableUUID = \"true\"" in your VMX file! >&2
}

# Rescan all SCSI buses for new devices
rescan() { chkroot && for scsi in /sys/class/scsi_host/*/scan ; do echo - - - > $scsi ; done ; }

# List functions
devinfoprint() {
  # List all configured asmdisks volumes and their configuration
  case $SEPARATOR in
    T) printf "%s\t%s\t%s\t%s\n"        "$@" ;;
    *) printf "%-20s %11s %20s %-25s\n" "$@" ;;
  esac
}
diskinfoprint() {
  # List all raw disks and their configuration
  test $# -eq 0 && set -- Device SCSI Size Type Target
  case $SEPARATOR in
    T) printf "%s\t%s\t%s\t%8s\t%s\n"    "$@" ;;
    *) printf "%-15s %10s %10s %-8s %s\n" "$@" ;;
  esac
}
mpinfoprint() {
  # List multipath devices and their configuration
  test $# -eq 0 && set -- Device Multi Size Type Volume
  case $SEPARATOR in
    T) printf "%s\t%s\t%s\t%s\t%s\n"     "$@" ;;
    *) printf "%-10s %10s %10s %-8s %s\n" "$@" ;;
  esac
}

createconf() {
  if [ ! -f /etc/asmtab ]; then
    cat <<- EOF > /etc/asmtab
	# /etc/asmtab - configuration file for asmdisks
	# Definitions for IORate testing - volumes under /dev/iorate will have root:iops @ mode 0601
	# PATH=iorate:root:iops:0660
	#
	# Specify bootdisk if not auto detected. This device will never be touched by $(basename $0)
	# BOOTDISK=/dev/sdc
	#
	# Alternative default permissions for /dev/oracleasm (uncomment):
	# PATH=oracleasm:oracle:dba:0660
	#
	# This file keeps track of udev disk mappings for asmdisk(1)
	# You should normally not have to edit this file directly
	# Use asm(1) instead.
	#
	# On each line:
	#
	# label type identifier
	# where
	# label: diskstring/volume name (default diskstring is oracleasm and can be omitted)
	# type:  one of scsi, part, part=scsi disk partition, ppath, dssd, scini,
	#   mapper (scsi=entire SCSI disk, part=scsi disk partition, mapper=linux disk mapper device)
	# label: scsi_id, scsi_id:partition, mapper_name, vol_id etc
	#
	# Ownerships and permissions can be specified for a diskstring:
	# PATH=diskstring:owner:group:mode
	# default is oracleasm:grid:asmdba:0660
	#
	# example:
	# vol1 scsi 36000c29f825cd85b5fcc70a1aadebf0c   # entire SCSI disk
	# vol2 part 36000c298afa5c31b47fe76cbd1750937:1 # partition 1 of entire SCSI disk
	# vol3 mapper mpathb                            # /dev/mapper/mpathb (multipath device)
	# vol4 ppath emcpowerx                          # /dev/emcpowerx (EMC Powerpath device)
	# vol5 dssd cca2a87a-6826-4424-a7dd-540cb3a0260b-000000000000003b # dssd volume
	# vol6 scini 6e85d4fe3b125edc-6f99ffeb00000000  # ScaleIO volume
	# iorate/test1 mapper iops-vol1                 # LV vol1 on VG iops, will be mapped as /dev/iorate/test1
	# -----------------------------------------------
	EOF
  fi
}

# Defines a new volume in asmtab and enables it via UDEV
createdisk() {
  chkroot
  label=$1 ; shift ; device=$1 ; shift
  echo $label | grep -qs "/" && DISKSTRING=${label%%/*}
  DISKSTRING=${DISKSTRING:-oracleasm}
  NODE=${label##*/}
  # check for existing volumes / devices
  awk -v x=$label '$1 !~ "#" && NF==3 && $1==x { exit 1 ; }' /etc/asmtab || rc=10 die "Volume already exists in asmtab!"
  # check if volume already exists under diskstring
  test -b ${DISKSTRING}/$label && err "Volume already exists in $DISKSTRING!" && exit 10
  test -L ${DISKSTRING}/$label && err "Volume already exists in $DISKSTRING!" && exit 10
  # get major and minor device number
  major=$(major $device)
  minor=$(minor $device)
  # Ask blkid for the fs type. Only unused and existing ASM volumes are allowed
  FSTYPE=$(blkid -p -o udev $device | awk -F= '$1=="ID_FS_TYPE" || $1 =="ID_PART_TABLE_TYPE" {print $2}'|head -1)
  case $FSTYPE in
    "")	       ;;
    oracleasm) ;;
    *)         err "Device already in use!" ; exit 10 ;;
  esac
  case $(devtrans $major) in
    sd) # is SCSI disk or -partition
      # check if disk has scsi id
      scsi=$(getscsi ${device%%[0-9]*}|tr -s ' ' '_')
      test -z "$scsi" && rc=10 die "Device not found!"
      # Prevent AWK conversion of SCSI ids to numbers by prefix with "x" (nasty bug):
      awk -v s="$scsi" '"x"$3=="x"s {exit 1;}' /etc/asmtab || rc=10 die "Device with SCSI $scsi already exists in asmtab!"
      if ((minor%16!=0)); then
        # it's a partition on a disk
        # check if partition is in use
        # ................
        :
      else
        # it's a full disk
        # check if device has partitions - probably obsolete due to blkid check before
        grep -q ${device##*/}[1-9] /proc/partitions && rc=10 die "Device already has partitions!"
        # second check (to be sure: parted)
        test parted -s $device print &>/dev/null && rc=10 die "Device already has (empty?) partition table!"$'\n'"Wipe the disk (using dd) before using it in ASM"
      fi
      # now add the vol to asmtab
      case $((minor%16)) in
        0) TGT="$scsi" ;;
        *) TGT="$scsi:$((minor%16))" ;;
      esac
      echo "$label scsi $TGT" >> /etc/asmtab
      ;;
    device-mapper) # is logical volume or device mapper volume
      dmname=$(dmsetup info -j $major -m $minor -c --nameprefixes  --rows -o name | awk -F= '{print $2}' | tr -d \')
      awk -v m="$dmname" '$3==m {exit 1;}' /etc/asmtab || rc=10 die "Mapper device $dmname already exists in asmtab!"
      echo "$label mapper $dmname" >> /etc/asmtab
      ;;
    dssd) # device is EMC DSSD disk
      oid=$(cat /sys/block/${device##*/}/dssd_mp/oid)
      awk -v m="$oid" '$3==m {exit 1;}' /etc/asmtab || rc=10 die "DSSD device with ID $oid already exists in asmtab!"
      echo "$label dssd $oid" >> /etc/asmtab
      ;;
    scini) # device is EMC ScaleIO disk
      oid=$(/bin/emc/scaleio/drv_cfg --query_block_device_id --block_device ${device})
      awk -v m="$oid" '$3==m {exit 1;}' /etc/asmtab || rc=10 die "ScaleIO device with ID $oid already exists in asmtab!"
      echo "$label scini $oid" >> /etc/asmtab
      ;;
    power2) # is EMC Powerpath volume
      if ((minor%16==0)); then
        [[ -x /sbin/powermt ]] && ppvol=$(/sbin/powermt display dev=${device##*/} 2>/dev/null | awk -F= '/Pseudo name/ {print $2}')
        echo "$label ppath $ppvol" >> /etc/asmtab
      else
        # is partition on EMC Powerpath volume
        parent=$(readlink -f /sys/class/block/${device##*/} | awk -F/ '{print $(NF-1)}')
        [[ -x /sbin/powermt ]] && ppvol=$(/sbin/powermt display dev=$parent 2>/dev/null | awk -F= '/Pseudo name/ {print $2}')
        test -n "$ppvol" && echo "$label ppath ${ppvol}:$((minor%16))" >> /etc/asmtab
      fi
      ;;
    *) # Unknown device type
      err "Unknown device type $(devtrans $major)" ; exit 99 ;;
  esac
  scandisks
}

# Delete disk from asmtab and update udev
deletedisk() {
  chkroot
  label=$1
  # check for existing devices
  VOLS=$(awk -v VOL=$label '$1 == VOL { print $0 }' /etc/asmtab | wc -l)
  ((VOLS==0)) && echo "Volume not found in asmtab!" && exit 10
  echo $label | grep -qs "/" && { DISKSTRING=${label%%/*} ; }
  DISKSTRING=${DISKSTRING:-oracleasm}
  NODE=${label##*/}
  # remove it from asmtab
  sed -i.bak -e "/^${label//\//\\/}\s/d" /etc/asmtab
  # remove it from udev path
  rm -f /dev/$DISKSTRING/$NODE
  # update udev
  scandisks
}

# build new rulesfile from asmtab and activates it
scandisks() {
  chkroot
  bootdisk=$(bootdisk | awk -F/ '{print $NF}')
  cat <<- EOF > $WORKDIR/99-asm.rules
	# This file was automatically generated by the /usr/bin/asm program.
	#
	# It's recommended not to edit this file directly as it will be overwritten
	# with each run of the "asm" command.
	# Direct edit the file /etc/asmtab instead.
	EOF

  # Insert DSSD header if DSSD config lines detected
  # Note: old method (not working?)
  #	SUBSYSTEM=="block" KERNEL=="dssd????*" IMPORT{program}="dssd_id %k %S"
  #	SUBSYSTEM=="block" KERNEL=="dssd????*" IMPORT{program}="blkid -o udev -p $tempnode"
  #	Also not working correctly:
  #	SUBSYSTEM=="block" KERNEL=="dssd????*" IMPORT{program}="dssd_id -e \$tempnode"
  awk '$2=="dssd" { f=1 ; } END { exit !f ;}' /etc/asmtab && cat <<- EOF >> $WORKDIR/99-asm.rules
	
	# Early detect DSSD OID - before 999-dssd-asm.rules is processed
	SUBSYSTEM=="block" KERNEL=="dssd????*" IMPORT{program}="dssd_id %k %S"
	SUBSYSTEM=="block" KERNEL=="dssd????*" IMPORT{program}="blkid -o udev -p \$tempnode"
	EOF
  cat <<- EOF >> $WORKDIR/99-asm.rules

	SUBSYSTEM!="block", GOTO="asmudev_end"
	
	# Don't touch the bootdisk (/dev/${bootdisk:-notfound})
	ENV{DEVPATH}=="*/block/${bootdisk:-none}", GOTO="asmudev_end"
	
	# force group "disk" for all disks not in asmtab
	# to prevent disks having wrong permissions after being deleted from asmtab
	GROUP="disk", ENV{DEVTYPE}=="disk", KERNEL=="sd*"
	GROUP="disk", ENV{DEVTYPE}=="partition", KERNEL=="sd*"
	
	EOF
  awk 'NF == 3 && $1 !~ "#"' /etc/asmtab | sort | while read VOL TYPE ID
  do
    # Build udev string
    unset OWNER GROUP MODE
    VOLNAME=${VOL##*/}
    DISKSTRING="oracleasm"
    echo $VOL | grep -qs "/" &&  DISKSTRING=${VOL%/*} 
    OWNER=$(awk -F'[=:]' -v DS=$DISKSTRING '$1 !~ "#" && $1=="PATH" && $2==DS {print $3}' /etc/asmtab)
    GROUP=$(awk -F'[=:]' -v DS=$DISKSTRING '$1 !~ "#" && $1=="PATH" && $2==DS {print $4}' /etc/asmtab)
    MODE=$(awk  -F'[=:]' -v DS=$DISKSTRING '$1 !~ "#" && $1=="PATH" && $2==DS {print $5}' /etc/asmtab)
    OWNER=${OWNER:-grid}
    GROUP=${GROUP:-asmdba}
    MODE=${MODE:-0660}
    LINE='OWNER="'$OWNER'", GROUP="'$GROUP'", MODE="'$MODE'"'
    if echo $ID | grep -q ":" ; then
      case $TYPE in
        ppath) TYPE=pppart ;;
            *) TYPE=part ;;
      esac
    fi
    case $TYPE in
      mapper)
        test ! -L /dev/mapper/$ID && msg "Mapper volume '$ID' does not exist, skipping" && continue
	LINE=${LINE}', ENV{DM_NAME}=="'$ID'"'
        SUBSYS=$(dmsetup info -c $ID --noheadings -o subsystem)
	case $SUBSYS in
	  LVM|mpath|part*) ;;
          *) echo "unknown disk mapper subsystem type $SUBSYS" ; exit 10 ;;
	esac ;;
      part)   LINE=${LINE}', ENV{DEVTYPE}=="partition", KERNEL=="sd*'${ID#*:}'", ENV{ID_SERIAL}=="'${ID%:*}'"' ;;
      pppart) LINE=${LINE}', ENV{DEVTYPE}=="partition", KERNEL=="'${ID%:*}${ID#*:}'"' ;;
      scsi)   LINE=${LINE}', ENV{DEVTYPE}=="disk", KERNEL=="sd*", ENV{ID_SERIAL}=="'$ID'"' ;;
      ppath)  LINE=${LINE}', ENV{DEVTYPE}=="disk", KERNEL=="'$ID'"' ;;
      dssd)   LINE=${LINE}', ENV{DSSD_OID}=="'$ID'"' ;;
      scini)  LINE=${LINE}', KERNEL=="scini*", PROGRAM="/opt/emc/scaleio/sdc/bin/drv_cfg --query_block_device_id --block_device /dev/%k", RESULT=="'$ID'" ' ;;
      *) echo "unknown asmudev volume type $TYPE" ; exit 10 ;;
    esac
    LINE=${LINE}', SYMLINK+="'$DISKSTRING'/'$VOLNAME'"'
    echo $LINE >> $WORKDIR/99-asm.rules
  done
  cat <<- EOF >> $WORKDIR/99-asm.rules
	
	LABEL="asmudev_end"
	EOF

  cmp -s $WORKDIR/99-asm.rules ${rulesfile:-none} || {
    echo Updating asm rules
    cat $WORKDIR/99-asm.rules > ${rulesfile:-none}
  }
  udevupdate
}

devinfo() {
  local vol=$1
  local volname=$(echo $vol | sed "s/\/dev\///;s/oracleasm\///")
  local major=$(major $vol)
  local minor=$(minor $vol)
  local dtype name blocks gbytes
  devtype=$(devicetype $major)
  devname=$(readlink -f /sys/dev/block/${major}\:${minor} | awk -F/ '{print $NF}')
  case $devtype in
    sd)            (($minor%16==0)) && dtype=scsi || dtype=partition ;;
    dssd)          dtype=dssd ;;
    device-mapper) dtype=mapper ;;
    *)             dtype=unknown ;;
  esac
  case $dtype in
    scsi)      name=$(lsscsi -k 2>/dev/null | awk -v D=/dev/$devname '$NF==D {print $1}') ;;
    partition) name="part$((min%16))" ;;
    mapper)    name=$(dmsetup info -j "$major" -m "$minor" -c --noheadings -o name) ;;
    dssd)      name=$(cat /sys/dev/block/${major}\:${minor}/dssd_mp/oid 2>/dev/null | awk -F- '{print $NF}') ;;
    *)         name="-" ;;
  esac
  blocks=$(cat /sys/dev/block/${major}\:${minor}/size)
  gbytes=$(echo "scale=1;$blocks/2/1024/1024"|bc)
  devinfoprint ${volname:-volume} "${gbytes} GB" "${name:-name}" ${devname:-devname}
}

list() {
  test -z "$NOHEAD" && devinfoprint Volume Size Target Devname
  for diskstring in $(diskstrings); do
    test -d /dev/$diskstring && for v in $(find /dev/$diskstring -type l -o -type b | sort); do devinfo $v ; done
  done
}

diskinfo() {
  local dev size realpath fstype disktype scsi symlink target mpvol ppvol
  dev=${1##*/}
  size=$(echo "scale=1;$(cat /sys/block/$dev/size)/2/1024/1024"|bc)
  realpath=$(udevadm info --root --query=name --path=/block/$dev)
  symlink=$(printf "%s\n" $(udevadm info --root --query=symlink --path=/block/$dev) | grep -Ev "^/dev/disk|^/dev/block" | head -1)
  scsi=$(lsscsi -k | awk -v D=/dev/$dev '$NF==D {print $1}')
  test -b $realpath || return
  ptable=$(blkid -p -o udev $realpath 2>/dev/null | awk -F= '$1=="ID_PART_TABLE_TYPE" {print $2}'|head -1)
  fstype=$(blkid -p -o udev $realpath 2>/dev/null | awk -F= '$1=="ID_FS_TYPE"         {print $2}'|head -1)
  test -x /sbin/multipath && test -f /etc/multipath.conf && mpvol=$(multipath -ll -v 1 /dev/$dev)
  test -x /sbin/powermt   && ppvol=$(/sbin/powermt display dev=$dev 2>/dev/null | awk -F= '/Pseudo name/ {print $2}')
  if [ "$ptable" == "dos" ]; then disktype="dos"
  elif [ "$ptable" == "gpt" ]; then disktype="gpt"
  else
    case $fstype in
      LVM2_member)       disktype="lvm" ;;
      linux_raid_member) disktype="raid" ;;
      oracleasm)         disktype="asm" ;;
      xfs|ext*)          disktype="$fstype" ;;
      "")                disktype="blank" ;;
      *)                 disktype="unknown" ;;
    esac
  fi
  test -n "$symlink" && target=$symlink
  test -n "$mpvol"  && target="($mpvol)"
  [[ "$ppvol" != "$dev" ]] && test -n "$ppvol"  && target="($ppvol)"
  diskinfoprint "/dev/$dev" "${scsi:-[-]}" "${size} GB" "${disktype:-unset}" ${target:--}
}

listdisks() {
  test -z "$NOHEAD" && diskinfoprint
  local d maj min dt
  for d in $(find /sys/block/ -mindepth 1 -maxdepth 1|cut -d/ -f4|sort); do
    major=$(cat /sys/block/$d/dev | cut -d: -f1)
    dt=$(devtrans $major)
    case $dt in
      sd|dssd|scini|power2) diskinfo $d ;;
    esac
  done
}

mpinfo() {
  local device dev size realpath fstype disktype map_id scsi_id mpvol
  device=$1
  dev=$(dmsetup ls -o blkdevname | awk -v MP=$device '$1==MP {print $2}'|tr -d '()')
  mpvol=$(multipath -ll -v 1 /dev/mapper/$device)
  size=$(echo "scale=1;$(cat /sys/block/$dev/size)/2/1024/1024"|bc)
  ptable=$(blkid -p -o udev /dev/$dev | awk -F= '$1=="ID_PART_TABLE_TYPE" {print $2}'|head -1)
  fstype=$(blkid -p -o udev /dev/$dev | awk -F= '$1=="ID_FS_TYPE" {print $2}'|head -1)
  if [ "$ptable" == "dos" ]; then disktype="dos"
  elif [ "$ptable" == "gpt" ]; then disktype="gpt"
  else
    case $fstype in
      LVM2_member)       disktype="lvm" ;;
      linux_raid_member) disktype="raid" ;;
      oracleasm)         disktype="asm" ;;
      xfs|ext*)          disktype="$fstype" ;;
      "")                disktype="blank" ;;
      *)                 disktype="unknown" ;;
    esac
  fi
  for ds in $(diskstrings) ; do
    realpath=${realpath:-$(udevadm info --query=symlink --path=/sys/block/$dev | tr ' ' '\n' | grep "^${ds}/")}
  done
  realpath=${realpath:--}
  mpinfoprint "$dev" "[$mpvol]" "${size} GB" "${disktype:-blank}" ${realpath:--}
}

# List all multipath volumes
listmulti() {
  test -z "$NOHEAD" && mpinfoprint
  if [ -x /sbin/multipath -a -f /etc/multipath.conf ]; then
    for d in $(multipath -ll -v1|sort); do mpinfo $d ; done
  fi
}

# Create a volume from every unassigned disk with an ASM label
importdisks() {
  for dev in $(asm -t disks | awk '$5=="asm" && $6=="-" {print $1}') ; do
    for i in {1..99} ; do
      volname=$(printf "vol%02d\n" $i)
      [[ ! -b /dev/oracleasm/${volname} ]] && break
    done
    echo importing $dev as /dev/oracleasm/$volname
    createdisk $volname $dev
    sleep 1
  done
}

# Rename a disk (volume) in asmtab and update
renamedisk() {
  chkroot
  label=$1
  newname=$2
  # check for existing devices
  VOLS=$(awk -v VOL=$label '$1 == VOL { print $0 }' /etc/asmtab | wc -l)
  if [ $VOLS -eq 0 ]; then
    echo "Volume not found in asmtab!"
    exit 10
  fi
  echo $label | grep -qs "/" && DISKSTRING=${label%%/*}
  DISKSTRING=${DISKSTRING:-oracleasm}
  NODE=${label##*/}
  # rename in asmtab
  sed -i.bak -e "s|^\<${label}\>|${newname}|" /etc/asmtab
  rm -f /dev/$DISKSTRING/$NODE
  scandisks
}

#============================================================================
# Main section - parsing options etc
# ---------------------------------------------------------------------------
while getopts ":hndt" OPT; do
  case "$OPT" in
      n) NOHEAD=Y ;;
      d) DEBUG=Y ;;
      t) SEPARATOR=T ; NOHEAD=Y ;;
   \?|h) usage >&2 ; exit 0 ;;
  esac
done
shift $(expr $OPTIND - 1)

ACTION=${1:-none}; shift

createconf
checkuuid

case $ACTION in
  rescan)           rescan ;;
  createdisk)       createdisk "$@" ;;
  deletedisk)       deletedisk "$@" ;;
  renamedisk)       renamedisk "$@" ;;
  import)           importdisks ;;
  scandisks)        scandisks ;;
  listmulti|multi)  listmulti ;;
  listdisks|disks)  listdisks ;;
  list)		    list ;;
  bootdisk)         bootdisk ;;
  dump)             cat $rulesfile ;;
  *)                usage ; exit 0 ;;
esac

rc=0
